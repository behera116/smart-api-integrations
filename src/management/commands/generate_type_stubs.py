"""
Management command to generate type stub files (.pyi) from provider configurations.

This allows developers to have full static typing support without writing boilerplate.
"""

import os
import yaml
from pathlib import Path
from django.core.management.base import BaseCommand
from typing import Dict, Any, List


class Command(BaseCommand):
    help = 'Generate type stub files (.pyi) from provider configurations'

    def add_arguments(self, parser):
        parser.add_argument(
            '--provider',
            type=str,
            help='Generate stubs for specific provider (default: all providers)'
        )
        parser.add_argument(
            '--output-dir',
            type=str,
            default='newfies/smart_api/typings',
            help='Output directory for type stub files'
        )

    def handle(self, *args, **options):
        provider_name = options.get('provider')
        output_dir = Path(options['output_dir'])
        
        if provider_name:
            self.generate_stub_for_provider(provider_name, output_dir)
        else:
            self.generate_all_stubs(output_dir)

    def generate_all_stubs(self, output_dir: Path):
        """Generate type stubs for all providers."""
        providers_dir = Path('newfies/smart_api/providers')
        
        if not providers_dir.exists():
            self.stdout.write(self.style.ERROR(f"Providers directory not found: {providers_dir}"))
            return
        
        for provider_dir in providers_dir.iterdir():
            if provider_dir.is_dir() and (provider_dir / 'config.yaml').exists():
                provider_name = provider_dir.name
                self.generate_stub_for_provider(provider_name, output_dir)

    def generate_stub_for_provider(self, provider_name: str, output_dir: Path):
        """Generate type stub for a specific provider."""
        config_path = Path(f'newfies/smart_api/providers/{provider_name}/config.yaml')
        
        if not config_path.exists():
            self.stdout.write(self.style.ERROR(f"Config not found: {config_path}"))
            return
        
        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
            
            stub_content = self.generate_stub_content(provider_name, config)
            
            # Write stub file
            stub_path = output_dir / f'{provider_name}.pyi'
            output_dir.mkdir(parents=True, exist_ok=True)
            
            with open(stub_path, 'w') as f:
                f.write(stub_content)
            
            self.stdout.write(
                self.style.SUCCESS(f"Generated type stub: {stub_path}")
            )
            
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f"Error generating stub for {provider_name}: {e}")
            )

    def generate_stub_content(self, provider_name: str, config: Dict[str, Any]) -> str:
        """Generate the content of a type stub file."""
        class_name = f"{provider_name.title()}APIClient"
        
        # Header
        stub_lines = [
            f'"""',
            f'Type stubs for {class_name} - provides static typing without boilerplate.',
            f'',
            f'This file is automatically generated from the provider configuration.',
            f'IDEs will use these type hints for autocomplete and type checking.',
            f'"""',
            f'',
            f'from typing import Optional, List, Dict, Any',
            f'from ..core.schema import APIResponse',
            f'from ..clients.universal import UniversalAPIClient',
            f'',
            f'',
            f'class {class_name}(UniversalAPIClient):',
            f'    """{ config.get("description", f"{provider_name.title()} API Client")} with full type support."""',
            f'    ',
            f'    def __init__(self, token_value: Optional[str] = None) -> None: ...',
            f'    ',
        ]
        
        # Generate method stubs from endpoints
        endpoints = config.get('endpoints', {})
        
        for endpoint_name, endpoint_config in endpoints.items():
            method_stub = self.generate_method_stub(endpoint_name, endpoint_config)
            stub_lines.extend(method_stub)
            stub_lines.append('    ')
        
        # Add mapped methods if any client defines them
        # This is a placeholder - in practice, you'd read METHOD_MAPPING from the client class
        stub_lines.extend([
            '    # Mapped methods (add custom mappings here)',
            '    # Example:',
            '    # def custom_method_name(self, **kwargs: Any) -> APIResponse: ...',
        ])
        
        return '\n'.join(stub_lines)

    def generate_method_stub(self, endpoint_name: str, endpoint_config: Dict[str, Any]) -> List[str]:
        """Generate a method stub for a single endpoint."""
        method = endpoint_config.get('method', 'GET').upper()
        path = endpoint_config.get('path', '')
        description = endpoint_config.get('description', f'Call {endpoint_name} endpoint')
        parameters = endpoint_config.get('parameters', {})
        
        # Analyze parameters
        required_params = []
        optional_params = []
        body_params = []
        
        for param_name, param_def in parameters.items():
            param_location = param_def.get('in', 'query')
            param_required = param_def.get('required', False)
            
            if param_location == 'body':
                body_params.append(param_name)
            elif param_required:
                required_params.append(param_name)
            else:
                optional_params.append(param_name)
        
        # Build method signature
        method_lines = [
            f'    def {endpoint_name}(',
            f'        self,',
            f'        *,',
        ]
        
        # Add parameter hints
        if required_params or optional_params:
            if required_params:
                param_comment = f'  # {", ".join(required_params)} (required)'
                if optional_params:
                    param_comment += f', {", ".join(optional_params)}'
            else:
                param_comment = f'  # {", ".join(optional_params)}'
            
            method_lines.append(f'        params: {"Dict[str, Any]" if required_params else "Optional[Dict[str, Any]] = None"},{param_comment}')
        
        # Add body parameters for POST/PUT/PATCH
        if method in ['POST', 'PUT', 'PATCH'] and body_params:
            body_comment = f'  # {", ".join(body_params)}'
            if any(param_def.get('required', False) for param_def in parameters.values() if param_def.get('in') == 'body'):
                method_lines.append(f'        json_data: Dict[str, Any],{body_comment}')
            else:
                method_lines.append(f'        json_data: Optional[Dict[str, Any]] = None,{body_comment}')
            
            # Add alternative parameter names
            method_lines.extend([
                f'        json: Optional[Dict[str, Any]] = None,  # Alternative parameter name',
                f'        body: Optional[Dict[str, Any]] = None,  # Alternative parameter name',
            ])
        
        method_lines.extend([
            f'    ) -> APIResponse:',
            f'        """{method} {path} - {description}"""',
            f'        ...',
        ])
        
        return method_lines 